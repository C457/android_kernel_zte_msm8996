--- drivers/gpu/msm/kgsl_iommu.c	2017-03-12 21:44:07.000000000 -0500
+++ drivers/gpu/msm/kgsl_iommu.c	2017-05-08 21:34:57.000000000 -0500
@@ -96,19 +100,41 @@
 
 #define GLOBAL_PT_ENTRIES 32
 
-static struct kgsl_memdesc *global_pt_entries[GLOBAL_PT_ENTRIES];
+struct global_pt_entry {
+	struct kgsl_memdesc *memdesc;
+	char name[32];
+};
+
+static struct global_pt_entry global_pt_entries[GLOBAL_PT_ENTRIES];
 static struct kgsl_memdesc *kgsl_global_secure_pt_entry;
 static int global_pt_count;
 uint64_t global_pt_alloc;
 static struct kgsl_memdesc gpu_qdss_desc;
 
+void kgsl_print_global_pt_entries(struct seq_file *s)
+{
+	int i;
+
+	for (i = 0; i < global_pt_count; i++) {
+		struct kgsl_memdesc *memdesc = global_pt_entries[i].memdesc;
+
+		if (memdesc == NULL)
+			continue;
+
+		seq_printf(s, "0x%16.16llX-0x%16.16llX %16llu %s\n",
+			memdesc->gpuaddr, memdesc->gpuaddr + memdesc->size - 1,
+			memdesc->size, global_pt_entries[i].name);
+	}
+}
+
 static void kgsl_iommu_unmap_globals(struct kgsl_pagetable *pagetable)
 {
 	unsigned int i;
 
 	for (i = 0; i < global_pt_count; i++) {
-		if (global_pt_entries[i] != NULL)
-			kgsl_mmu_unmap(pagetable, global_pt_entries[i]);
+		if (global_pt_entries[i].memdesc != NULL)
+			kgsl_mmu_unmap(pagetable,
+					global_pt_entries[i].memdesc);
 	}
 }
 
@@ -117,8 +143,9 @@
 	unsigned int i;
 
 	for (i = 0; i < global_pt_count; i++) {
-		if (global_pt_entries[i] != NULL) {
-			int ret = kgsl_mmu_map(pagetable, global_pt_entries[i]);
+		if (global_pt_entries[i].memdesc != NULL) {
+			int ret = kgsl_mmu_map(pagetable,
+					global_pt_entries[i].memdesc);
 
 			BUG_ON(ret);
 		}
@@ -156,17 +183,17 @@
 		return;
 
 	for (i = 0; i < global_pt_count; i++) {
-		if (global_pt_entries[i] == memdesc) {
+		if (global_pt_entries[i].memdesc == memdesc) {
 			memdesc->gpuaddr = 0;
 			memdesc->priv &= ~KGSL_MEMDESC_GLOBAL;
-			global_pt_entries[i] = NULL;
+			global_pt_entries[i].memdesc = NULL;
 			return;
 		}
 	}
 }
 
 static void kgsl_iommu_add_global(struct kgsl_mmu *mmu,
-		struct kgsl_memdesc *memdesc)
+		struct kgsl_memdesc *memdesc, const char *name)
 {
 	if (memdesc->gpuaddr != 0)
 		return;
@@ -178,7 +205,10 @@
 	memdesc->priv |= KGSL_MEMDESC_GLOBAL;
 	global_pt_alloc += memdesc->size;
 
-	global_pt_entries[global_pt_count++] = memdesc;
+	global_pt_entries[global_pt_count].memdesc = memdesc;
+	strlcpy(global_pt_entries[global_pt_count].name, name,
+			sizeof(global_pt_entries[global_pt_count].name));
+	global_pt_count++;
 }
 
 void kgsl_add_global_secure_entry(struct kgsl_device *device,
@@ -224,7 +254,7 @@
 		return;
 	}
 
-	kgsl_mmu_add_global(device, &gpu_qdss_desc);
+	kgsl_mmu_add_global(device, &gpu_qdss_desc, "gpu-qdss");
 }
 
 static inline void kgsl_cleanup_qdss_desc(struct kgsl_mmu *mmu)
@@ -489,8 +519,62 @@
 	unsigned int priv;
 	int pending_free;
 	pid_t pid;
+	char name[32];
 };
 
+static void _get_global_entries(uint64_t faultaddr,
+		struct _mem_entry *prev,
+		struct _mem_entry *next)
+{
+	int i;
+	uint64_t prevaddr = 0;
+	struct global_pt_entry *p = NULL;
+
+	uint64_t nextaddr = (uint64_t) -1;
+	struct global_pt_entry *n = NULL;
+
+	for (i = 0; i < global_pt_count; i++) {
+		uint64_t addr;
+
+		if (global_pt_entries[i].memdesc == NULL)
+			continue;
+
+		addr = global_pt_entries[i].memdesc->gpuaddr;
+		if ((addr < faultaddr) && (addr > prevaddr)) {
+			prevaddr = addr;
+			p = &global_pt_entries[i];
+		}
+
+		if ((addr > faultaddr) && (addr < nextaddr)) {
+			nextaddr = addr;
+			n = &global_pt_entries[i];
+		}
+	}
+
+	if (p != NULL) {
+		prev->gpuaddr = p->memdesc->gpuaddr;
+		prev->size = p->memdesc->size;
+		prev->flags = p->memdesc->flags;
+		prev->priv = p->memdesc->priv;
+		prev->pid = 0;
+		strlcpy(prev->name, p->name, sizeof(prev->name));
+	}
+
+	if (n != NULL) {
+		next->gpuaddr = n->memdesc->gpuaddr;
+		next->size = n->memdesc->size;
+		next->flags = n->memdesc->flags;
+		next->priv = n->memdesc->priv;
+		next->pid = 0;
+		strlcpy(next->name, n->name, sizeof(next->name));
+	}
+}
+
+void __kgsl_get_memory_usage(struct _mem_entry *entry)
+{
+	kgsl_get_memory_usage(entry->name, sizeof(entry->name), entry->flags);
+}
+
 static void _get_entries(struct kgsl_process_private *private,
 		uint64_t faultaddr, struct _mem_entry *prev,
 		struct _mem_entry *next)
@@ -525,6 +609,7 @@
 		prev->priv = p->memdesc.priv;
 		prev->pending_free = p->pending_free;
 		prev->pid = private->pid;
+		__kgsl_get_memory_usage(prev);
 	}
 
 	if (n != NULL) {
@@ -534,6 +619,7 @@
 		next->priv = n->memdesc.priv;
 		next->pending_free = n->pending_free;
 		next->pid = private->pid;
+		__kgsl_get_memory_usage(next);
 	}
 }
 
@@ -549,7 +635,9 @@
 	/* Set the maximum possible size as an initial value */
 	nextentry->gpuaddr = (uint64_t) -1;
 
-	if (context) {
+	if (ADDR_IN_GLOBAL(faultaddr)) {
+		_get_global_entries(faultaddr, preventry, nextentry);
+	} else if (context) {
 		private = context->proc_priv;
 		spin_lock(&private->mem_lock);
 		_get_entries(private, faultaddr, preventry, nextentry);
@@ -559,18 +647,13 @@
 
 static void _print_entry(struct kgsl_device *device, struct _mem_entry *entry)
 {
-	char name[32];
-	memset(name, 0, sizeof(name));
-
-	kgsl_get_memory_usage(name, sizeof(name) - 1, entry->flags);
-
 	KGSL_LOG_DUMP(device,
 		"[%016llX - %016llX] %s %s (pid = %d) (%s)\n",
 		entry->gpuaddr,
 		entry->gpuaddr + entry->size,
 		entry->priv & KGSL_MEMDESC_GUARD_PAGE ? "(+guard)" : "",
 		entry->pending_free ? "(pending free)" : "",
-		entry->pid, name);
+		entry->pid, entry->name);
 }
 
 static void _check_if_freed(struct kgsl_iommu_context *ctx,
@@ -1385,7 +1467,7 @@
 		}
 	}
 
-	kgsl_iommu_add_global(mmu, &iommu->setstate);
+	kgsl_iommu_add_global(mmu, &iommu->setstate, "setstate");
 	kgsl_setup_qdss_desc(device);
 
 done:
@@ -2109,10 +2191,6 @@
 	return addr;
 }
 
-#define ADDR_IN_GLOBAL(_a) \
-	(((_a) >= KGSL_IOMMU_GLOBAL_MEM_BASE) && \
-	 ((_a) < (KGSL_IOMMU_GLOBAL_MEM_BASE + KGSL_IOMMU_GLOBAL_MEM_SIZE)))
-
 static int kgsl_iommu_set_svm_region(struct kgsl_pagetable *pagetable,
 		uint64_t gpuaddr, uint64_t size)
 {
