--- drivers/net/ethernet/msm/ecm_ipa.c	2017-03-12 21:44:08.000000000 -0500
+++ drivers/net/ethernet/msm/ecm_ipa.c	2017-05-08 21:34:58.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -158,32 +149,16 @@
 static struct net_device_stats *ecm_ipa_get_stats(struct net_device *net);
 static int ecm_ipa_create_rm_resource(struct ecm_ipa_dev *ecm_ipa_ctx);
 static void ecm_ipa_destory_rm_resource(struct ecm_ipa_dev *ecm_ipa_ctx);
-static bool rx_filter(struct sk_buff *skb);
-static bool tx_filter(struct sk_buff *skb);
-static bool rm_enabled(struct ecm_ipa_dev *ecm_ipa_ctx);
 static int resource_request(struct ecm_ipa_dev *ecm_ipa_ctx);
 static void resource_release(struct ecm_ipa_dev *ecm_ipa_ctx);
 static netdev_tx_t ecm_ipa_start_xmit(struct sk_buff *skb,
 					struct net_device *net);
-static int ecm_ipa_debugfs_stall_open(struct inode *inode,
-	struct file *file);
-static ssize_t ecm_ipa_debugfs_stall_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos);
 static int ecm_ipa_debugfs_atomic_open(struct inode *inode, struct file *file);
-static ssize_t ecm_ipa_debugfs_enable_write_dma(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos);
-static int ecm_ipa_debugfs_dma_open(struct inode *inode, struct file *file);
-static ssize_t ecm_ipa_debugfs_enable_write(struct file *file,
-		const char __user *buf, size_t count, loff_t *ppos);
-static ssize_t ecm_ipa_debugfs_enable_read(struct file *file,
-		char __user *ubuf, size_t count, loff_t *ppos);
 static ssize_t ecm_ipa_debugfs_atomic_read(struct file *file,
 		char __user *ubuf, size_t count, loff_t *ppos);
-static int ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx);
+static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx);
 static void ecm_ipa_debugfs_destroy(struct ecm_ipa_dev *ecm_ipa_ctx);
 static int ecm_ipa_ep_registers_cfg(u32 usb_to_ipa_hdl, u32 ipa_to_usb_hdl);
-static int ecm_ipa_ep_registers_dma_cfg(u32 usb_to_ipa_hdl,
-					enum ipa_client_type prod_client);
 static int ecm_ipa_set_device_ethernet_addr(u8 *dev_ethaddr,
 		u8 device_ethaddr[]);
 static enum ecm_ipa_state ecm_ipa_next_state(enum ecm_ipa_state current_state,
@@ -278,10 +239,7 @@
 		ECM_IPA_DEBUG("device_ready_notify() was not supplied");
 	ecm_ipa_ctx->device_ready_notify = params->device_ready_notify;
 
-	result = ecm_ipa_debugfs_init(ecm_ipa_ctx);
-	if (result)
-		goto fail_debugfs;
-	ECM_IPA_DEBUG("debugfs entries were created\n");
+	ecm_ipa_debugfs_init(ecm_ipa_ctx);
 
 	result = ecm_ipa_set_device_ethernet_addr(net->dev_addr,
 			params->device_ethaddr);
@@ -330,7 +288,6 @@
 fail_set_device_ethernet:
 fail_rules_cfg:
 	ecm_ipa_debugfs_destroy(ecm_ipa_ctx);
-fail_debugfs:
 fail_netdev_priv:
 	free_netdev(net);
 fail_alloc_etherdev:
@@ -1217,42 +1025,24 @@
 	return simple_read_from_buffer(ubuf, count, ppos, atomic_str, nbytes);
 }
 
+#ifdef CONFIG_DEBUG_FS
 
-static int ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx)
+static void ecm_ipa_debugfs_init(struct ecm_ipa_dev *ecm_ipa_ctx)
 {
 	const mode_t flags_read_write = S_IRUGO | S_IWUGO;
 	const mode_t flags_read_only = S_IRUGO;
-	const mode_t flags_write_only = S_IWUGO;
 	struct dentry *file;
 
 	ECM_IPA_LOG_ENTRY();
 
 	if (!ecm_ipa_ctx)
-		return -EINVAL;
+		return;
 
 	ecm_ipa_ctx->directory = debugfs_create_dir("ecm_ipa", NULL);
 	if (!ecm_ipa_ctx->directory) {
 		ECM_IPA_ERROR("could not create debugfs directory entry\n");
 		goto fail_directory;
 	}
-	file = debugfs_create_bool("tx_enable", flags_read_write,
-			ecm_ipa_ctx->directory, &ecm_ipa_ctx->tx_enable);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs tx file\n");
-		goto fail_file;
-	}
-	file = debugfs_create_bool("rx_enable", flags_read_write,
-			ecm_ipa_ctx->directory, &ecm_ipa_ctx->rx_enable);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs rx file\n");
-		goto fail_file;
-	}
-	file = debugfs_create_bool("rm_enable", flags_read_write,
-			ecm_ipa_ctx->directory, &ecm_ipa_ctx->rm_enable);
-	if (!file) {
-		ECM_IPA_ERROR("could not create debugfs rm file\n");
-		goto fail_file;
-	}
 	file = debugfs_create_u8("outstanding_high", flags_read_write,
 			ecm_ipa_ctx->directory, &ecm_ipa_ctx->outstanding_high);
 	if (!file) {
@@ -1273,21 +1056,14 @@
 		goto fail_file;
 	}
 
-	file = debugfs_create_file("stall_ipa_rx_proc", flags_write_only,
-			ecm_ipa_ctx->directory,
-			ecm_ipa_ctx, &ecm_ipa_debugfs_stall_ops);
-	if (!file) {
-		ECM_IPA_ERROR("could not create stall_ipa_rx_proc file\n");
-		goto fail_file;
-	}
-
+	ECM_IPA_DEBUG("debugfs entries were created\n");
 	ECM_IPA_LOG_EXIT();
 
-	return 0;
+	return;
 fail_file:
 	debugfs_remove_recursive(ecm_ipa_ctx->directory);
 fail_directory:
-	return -EFAULT;
+	return;
 }
 
 static void ecm_ipa_debugfs_destroy(struct ecm_ipa_dev *ecm_ipa_ctx)
@@ -1345,46 +1128,6 @@
 		goto out;
 	}
 	ECM_IPA_DEBUG("end-point registers successfully configured\n");
-out:
-	ECM_IPA_LOG_EXIT();
-	return result;
-}
-
-/**
- * ecm_ipa_ep_registers_dma_cfg() - configure the USB endpoints for ECM
- *	DMA
- * @usb_to_ipa_hdl: handle received from ipa_connect
- *
- * This function will override the previous configuration
- * which is needed for cores that does not support blocks logic
- * Note that client handles are the actual pipe index
- */
-static int ecm_ipa_ep_registers_dma_cfg(u32 usb_to_ipa_hdl,
-					enum ipa_client_type prod_client)
-{
-	int result = 0;
-	struct ipa_ep_cfg_mode cfg_mode;
-	u32 apps_to_ipa_hdl = 2;
-
-	ECM_IPA_LOG_ENTRY();
-
-	memset(&cfg_mode, 0 , sizeof(cfg_mode));
-	cfg_mode.mode = IPA_DMA;
-	cfg_mode.dst = prod_client;
-	result = ipa_cfg_ep_mode(apps_to_ipa_hdl, &cfg_mode);
-	if (result) {
-		ECM_IPA_ERROR("failed to configure Apps to IPA\n");
-		goto out;
-	}
-	memset(&cfg_mode, 0 , sizeof(cfg_mode));
-	cfg_mode.mode = IPA_DMA;
-	cfg_mode.dst = IPA_CLIENT_A5_LAN_WAN_CONS;
-	result = ipa_cfg_ep_mode(usb_to_ipa_hdl, &cfg_mode);
-	if (result) {
-		ECM_IPA_ERROR("failed to configure USB to IPA\n");
-		goto out;
-	}
-	ECM_IPA_DEBUG("end-point registers successfully configured\n");
 out:
 	ECM_IPA_LOG_EXIT();
 	return result;
