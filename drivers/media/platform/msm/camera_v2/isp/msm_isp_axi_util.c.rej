--- drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c	2017-03-12 21:44:07.000000000 -0500
+++ drivers/media/platform/msm/camera_v2/isp/msm_isp_axi_util.c	2017-05-08 21:34:57.000000000 -0500
@@ -17,10 +17,10 @@
 
 #define HANDLE_TO_IDX(handle) (handle & 0xFF)
 #define ISP_SOF_DEBUG_COUNT 0
-
 static int msm_isp_update_dual_HW_ms_info_at_start(
 	struct vfe_device *vfe_dev,
-	enum msm_vfe_input_src stream_src);
+	enum msm_vfe_input_src stream_src,
+	struct msm_isp_timestamp *ts);
 
 static int msm_isp_update_dual_HW_axi(
 	struct vfe_device *vfe_dev,
@@ -818,12 +818,14 @@
 	struct msm_vfe_sof_info *master_sof_info = NULL;
 	int32_t time, master_time, delta;
 	uint32_t sof_incr = 0;
+	uint32_t master_last_slave_diff = 0;
+	uint32_t last_curr_diff = 0;
 	unsigned long flags;
 
-	if (vfe_dev->axi_data.src_info[frame_src].frame_id == 0)
-		msm_isp_update_dual_HW_ms_info_at_start(vfe_dev, frame_src);
-
 	spin_lock_irqsave(&vfe_dev->common_data->common_dev_data_lock, flags);
+	if (vfe_dev->axi_data.src_info[frame_src].frame_id == 0)
+		msm_isp_update_dual_HW_ms_info_at_start(vfe_dev, frame_src,
+			ts);
 	dual_hw_type =
 		vfe_dev->axi_data.src_info[frame_src].dual_hw_type;
 	ms_type =
@@ -2158,8 +2179,7 @@
 				*camif_update = DISABLE_CAMIF_IMMEDIATELY;
 			else
 				*camif_update = DISABLE_CAMIF;
-		}
-		else
+		} else
 			*camif_update = NO_UPDATE;
 	} else
 		*camif_update = NO_UPDATE;
@@ -2184,25 +2204,31 @@
 		stream_info =
 			&axi_data->stream_info[
 			HANDLE_TO_IDX(stream_cfg_cmd->stream_handle[i])];
-		if (stream_info->stream_src >= RDI_INTF_0)
-			continue;
 		if (stream_info->stream_src == PIX_ENCODER ||
 			stream_info->stream_src == PIX_VIEWFINDER ||
 			stream_info->stream_src == PIX_VIDEO ||
 			stream_info->stream_src == IDEAL_RAW) {
 			if (stream_cfg_cmd->cmd == START_STREAM)
-				vfe_dev->axi_data.src_info[VFE_PIX_0].
+				vfe_dev->axi_data.src_info[
+					SRC_TO_INTF(stream_info->stream_src)].
 					pix_stream_count++;
 			else
-				vfe_dev->axi_data.src_info[VFE_PIX_0].
+				vfe_dev->axi_data.src_info[
+					SRC_TO_INTF(stream_info->stream_src)].
 					pix_stream_count--;
-		} else if (stream_info->stream_src == CAMIF_RAW) {
+		} else if (stream_info->stream_src == CAMIF_RAW ||
+				stream_info->stream_src == RDI_INTF_0 ||
+				stream_info->stream_src == RDI_INTF_1 ||
+				stream_info->stream_src == RDI_INTF_2) {
 			if (stream_cfg_cmd->cmd == START_STREAM)
-				vfe_dev->axi_data.src_info[VFE_PIX_0].
+				vfe_dev->axi_data.src_info[
+					SRC_TO_INTF(stream_info->stream_src)].
 					raw_stream_count++;
 			else
-				vfe_dev->axi_data.src_info[VFE_PIX_0].
+				vfe_dev->axi_data.src_info[
+					SRC_TO_INTF(stream_info->stream_src)].
 					raw_stream_count--;
+
 		}
 	}
 }
@@ -2525,15 +2561,16 @@
 
 static int msm_isp_update_dual_HW_ms_info_at_start(
 	struct vfe_device *vfe_dev,
-	enum msm_vfe_input_src stream_src)
+	enum msm_vfe_input_src stream_src,
+	struct msm_isp_timestamp *ts)
 {
 	int rc = 0;
-	uint32_t j, k, max_sof = 0;
+	uint32_t j, k, max_sof = 0, timestamp_ms = 0, cur_timestamp_ms = 0;
+	uint32_t delta;
 	uint8_t slave_id;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 	struct msm_vfe_src_info *src_info = NULL;
 	uint32_t vfe_id = 0;
-	unsigned long flags;
 
 	if (stream_src >= VFE_SRC_MAX) {
 		pr_err("%s: Error! Invalid src %u\n", __func__, stream_src);
@@ -2559,11 +2593,10 @@
 		 * without repeating.
 		 */
 		if (!vfe_dev->common_data->ms_resource.slave_active_mask) {
-			spin_unlock_irqrestore(&vfe_dev->common_data->
-				common_dev_data_lock, flags);
 			return rc;
 		}
-
+		cur_timestamp_ms = ts->buf_time.tv_sec * 1000 +
+			ts->buf_time.tv_usec / 1000;
 		for (j = 0, k = 0; k < MS_NUM_SLAVE_MAX; k++) {
 			if (!(vfe_dev->common_data->ms_resource.
 				reserved_slave_mask & (1 << k)))
@@ -2575,13 +2608,26 @@
 					slave_sof_info[k].frame_id > max_sof)) {
 				max_sof = vfe_dev->common_data->ms_resource.
 					slave_sof_info[k].frame_id;
+				timestamp_ms = vfe_dev->common_data->ms_resource
+					.slave_sof_info[k].mono_timestamp_ms;
 			}
 			j++;
 			if (j == vfe_dev->common_data->ms_resource.num_slave)
 				break;
 		}
+		if (cur_timestamp_ms > timestamp_ms)
+			delta = cur_timestamp_ms - timestamp_ms;
+		else
+			delta = timestamp_ms - cur_timestamp_ms;
+		if (delta > vfe_dev->common_data->ms_resource.
+			sof_delta_threshold) {
+			vfe_dev->axi_data.src_info[stream_src].frame_id =
+				max_sof;
+		} else {
 		vfe_dev->axi_data.src_info[stream_src].frame_id =
-			max_sof + 1;
+				max_sof - vfe_dev->axi_data.src_info[
+					stream_src].sof_counter_step;
+		}
 		if (vfe_dev->is_split) {
 			vfe_id = vfe_dev->pdev->id;
 			vfe_id = (vfe_id == 0) ? 1 : 0;
@@ -2750,6 +2793,7 @@
 		ISP_DBG("%s: vfe %d camif enable\n", __func__,
 			vfe_dev->pdev->id);
 		vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id = 0;
+		vfe_dev->axi_data.src_info[VFE_PIX_0].eof_id = 0;
 	}
 
 	for (i = 0; i < stream_cfg_cmd->num_streams; i++) {
@@ -2833,11 +2877,22 @@
 			}
 		}
 	}
-	msm_isp_update_stream_bandwidth(vfe_dev);
+	msm_isp_update_stream_bandwidth(vfe_dev, stream_cfg_cmd->hw_state);
 	vfe_dev->hw_info->vfe_ops.axi_ops.reload_wm(vfe_dev,
 		vfe_dev->vfe_base, wm_reload_mask);
 	msm_isp_update_camif_output_count(vfe_dev, stream_cfg_cmd);
-
+	for (i = 0; i < VFE_SRC_MAX; i++) {
+		if ((vfe_dev->axi_data.src_info[i].pix_stream_count ||
+			vfe_dev->axi_data.src_info[i].raw_stream_count) &&
+			!vfe_dev->axi_data.src_info[i].flag) {
+			/*Configure UB*/
+			vfe_dev->hw_info->vfe_ops.axi_ops.cfg_ub(vfe_dev, i);
+			/*when start reset overflow state*/
+			atomic_set(&vfe_dev->error_info.overflow_state,
+				NO_OVERFLOW);
+			vfe_dev->axi_data.src_info[i].flag = 1;
+		}
+	}
 	if (camif_update == ENABLE_CAMIF) {
 		vfe_dev->hw_info->vfe_ops.core_ops.
 			update_camif_state(vfe_dev, camif_update);
@@ -2912,7 +2967,6 @@
 				clear_wm_irq_mask(vfe_dev, stream_info);
 
 		stream_info->state = STOP_PENDING;
-
 		if (!halt && !ext_read &&
 			!(stream_info->stream_type == BURST_STREAM &&
 			stream_info->runtime_num_burst_capture == 0))
@@ -3053,14 +3107,6 @@
 		pr_err("%s: Invalid stream state\n", __func__);
 		return rc;
 	}
-
-	if (axi_data->num_active_stream == 0) {
-		/*Configure UB*/
-		vfe_dev->hw_info->vfe_ops.axi_ops.cfg_ub(vfe_dev);
-		/*when start reset overflow state*/
-		atomic_set(&vfe_dev->error_info.overflow_state,
-			NO_OVERFLOW);
-	}
 	msm_isp_get_camif_update_state_and_halt(vfe_dev, stream_cfg_cmd,
 		&camif_update, &halt);
 	if (camif_update == DISABLE_CAMIF)
@@ -3211,15 +3257,25 @@
 	}
 
 	frame_src = SRC_TO_INTF(stream_info->stream_src);
+	pingpong_status =
+		vfe_dev->hw_info->vfe_ops.axi_ops.get_pingpong_status(
+			vfe_dev);
 	/*
 	 * If PIX stream is active then RDI path uses SOF frame ID of PIX
 	 * In case of standalone RDI streaming, SOF are used from
 	 * individual intf.
 	 */
-	if (((vfe_dev->axi_data.src_info[VFE_PIX_0].active) && (frame_id <=
-		vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id)) ||
-		((!vfe_dev->axi_data.src_info[VFE_PIX_0].active) && (frame_id <=
-		vfe_dev->axi_data.src_info[frame_src].frame_id)) ||
+	/*
+	 * If frame_id = 1 then no eof check is needed
+	 */
+	if (((vfe_dev->axi_data.src_info[VFE_PIX_0].active) && ((frame_id !=
+		vfe_dev->axi_data.src_info[VFE_PIX_0].frame_id + vfe_dev->
+		axi_data.src_info[VFE_PIX_0].sof_counter_step) ||
+		(frame_id <= vfe_dev->
+		axi_data.src_info[VFE_PIX_0].eof_id + 1))) ||
+		((!vfe_dev->axi_data.src_info[VFE_PIX_0].active) && (frame_id !=
+		vfe_dev->axi_data.src_info[frame_src].frame_id + vfe_dev->
+		axi_data.src_info[frame_src].sof_counter_step)) ||
 		stream_info->undelivered_request_cnt >= MAX_BUFFERS_IN_HW) {
 		pr_debug("%s:%d invalid request_frame %d cur frame id %d pix %d\n",
 			__func__, __LINE__, frame_id,
@@ -3326,9 +3382,6 @@
 		}
 		stream_info->sw_ping_pong_bit = 0;
 	} else if (stream_info->undelivered_request_cnt == 2) {
-		pingpong_status =
-			vfe_dev->hw_info->vfe_ops.axi_ops.get_pingpong_status(
-				vfe_dev);
 		rc = msm_isp_cfg_ping_pong_address(vfe_dev,
 				stream_info, pingpong_status, 0);
 		if (rc) {
