--- drivers/media/platform/msm/camera_v2/isp/msm_isp47.c	2017-03-12 21:44:07.000000000 -0500
+++ drivers/media/platform/msm/camera_v2/isp/msm_isp47.c	2017-05-08 21:34:57.000000000 -0500
@@ -98,6 +98,7 @@
 	(~(ping_pong >> (stats_pingpong_offset_map[idx])) & 0x1) * 2)
 
 #define VFE47_SRC_CLK_DTSI_IDX 5
+#define HANDLE_TO_IDX(handle) (handle & 0xFF)
 
 static struct msm_bus_vectors msm_isp_init_vectors[] = {
 	{
@@ -191,7 +204,7 @@
 	struct msm_vfe_hw_init_parms *dt_parms, void __iomem *dev_mem_base)
 {
 	struct device_node *of_node;
-	int32_t i = 0 , rc = 0;
+	int32_t i = 0, rc = 0;
 	uint32_t *dt_settings = NULL, *dt_regs = NULL, num_dt_entries = 0;
 
 	of_node = vfe_dev->pdev->dev.of_node;
@@ -1475,7 +1495,7 @@
 		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x64);
 		msm_camera_io_w(0x81, vfe_dev->vfe_base + 0x68);
 		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x58);
-		msm_vfe47_config_irq(vfe_dev, 0x15, 0x81,
+		msm_vfe47_config_irq(vfe_dev, 0x17, 0x81,
 					MSM_ISP_IRQ_ENABLE);
 
 		if ((vfe_dev->hvx_cmd > HVX_DISABLE) &&
@@ -1672,7 +1692,7 @@
 
 
 void msm_vfe47_cfg_axi_ub_equal_default(
-	struct vfe_device *vfe_dev)
+	struct vfe_device *vfe_dev, enum msm_vfe_input_src frame_src)
 {
 	int i;
 	uint32_t ub_offset = 0;
@@ -1683,35 +1703,71 @@
 	uint32_t prop_size = 0;
 	uint32_t wm_ub_size;
 	uint64_t delta;
+	uint32_t rdi_ub_offset;
+	int plane;
+	struct msm_vfe_axi_stream *stream_info;
 
+	if (frame_src == VFE_PIX_0) {
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
-		if (axi_data->free_wm[i] > 0) {
+			if (axi_data->free_wm[i] &&
+				SRC_TO_INTF(
+				HANDLE_TO_IDX(axi_data->free_wm[i])) ==
+				VFE_PIX_0) {
 			num_used_wms++;
-			total_image_size += axi_data->wm_image_size[i];
+				total_image_size +=
+					axi_data->wm_image_size[i];
 		}
 	}
-	if (vfe_dev->pdev->id == ISP_VFE0) {
-		prop_size = MSM_ISP47_TOTAL_IMAGE_UB_VFE0 -
-		axi_data->hw_info->min_wm_ub * num_used_wms;
-	} else if (vfe_dev->pdev->id == ISP_VFE1) {
-		prop_size = MSM_ISP47_TOTAL_IMAGE_UB_VFE1 -
-		axi_data->hw_info->min_wm_ub * num_used_wms;
-	} else {
-		pr_err("%s: incorrect VFE device\n", __func__);
+		ub_offset = (axi_data->hw_info->num_rdi * 2) *
+			axi_data->hw_info->min_wm_ub;
+		prop_size = vfe_dev->hw_info->vfe_ops.axi_ops.
+			get_ub_size(vfe_dev) -
+			axi_data->hw_info->min_wm_ub * (num_used_wms +
+			axi_data->hw_info->num_rdi * 2);
 	}
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
-		if (axi_data->free_wm[i]) {
+		if (!axi_data->free_wm[i]) {
+			msm_camera_io_w(0,
+				vfe_dev->vfe_base +
+				vfe_dev->hw_info->vfe_ops.axi_ops.
+					ub_reg_offset(vfe_dev, i));
+		}
+		if (frame_src != SRC_TO_INTF(
+				HANDLE_TO_IDX(axi_data->free_wm[i])))
+			continue;
+
+		if (frame_src == VFE_PIX_0) {
 			delta = (uint64_t)axi_data->wm_image_size[i] *
 					(uint64_t)prop_size;
 			do_div(delta, total_image_size);
 			wm_ub_size = axi_data->hw_info->min_wm_ub +
 					(uint32_t)delta;
 			msm_camera_io_w(ub_offset << 16 | (wm_ub_size - 1),
-				vfe_dev->vfe_base + VFE47_WM_BASE(i) + 0x18);
+				vfe_dev->vfe_base +
+				vfe_dev->hw_info->vfe_ops.axi_ops.
+					ub_reg_offset(vfe_dev, i));
 			ub_offset += wm_ub_size;
-		} else
-			msm_camera_io_w(0,
-				vfe_dev->vfe_base + VFE47_WM_BASE(i) + 0x18);
+		} else {
+
+			stream_info =  &axi_data->stream_info[
+				HANDLE_TO_IDX(axi_data->free_wm[i])];
+			for (plane = 0; plane < stream_info->num_planes;
+					plane++)
+				if (stream_info->wm[plane] ==
+					axi_data->free_wm[i])
+					break;
+
+			rdi_ub_offset = ((SRC_TO_INTF(
+					HANDLE_TO_IDX(axi_data->free_wm[i])) -
+					VFE_RAW_0 * 2) + plane) *
+					axi_data->hw_info->min_wm_ub;
+			wm_ub_size = axi_data->hw_info->min_wm_ub * 2;
+			msm_camera_io_w((rdi_ub_offset << 16 |
+				(wm_ub_size - 1)),
+				vfe_dev->vfe_base +
+				vfe_dev->hw_info->vfe_ops.axi_ops.
+						ub_reg_offset(vfe_dev, i));
+		}
 	}
 }
 
@@ -1722,31 +1778,29 @@
 	uint32_t ub_offset = 0;
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 	uint32_t ub_equal_slice = 0;
-	if (vfe_dev->pdev->id == ISP_VFE0) {
-		ub_equal_slice = MSM_ISP47_TOTAL_IMAGE_UB_VFE0 /
-		axi_data->hw_info->num_wm;
-	} else if (vfe_dev->pdev->id == ISP_VFE1) {
-		ub_equal_slice = MSM_ISP47_TOTAL_IMAGE_UB_VFE1 /
+
+	ub_equal_slice = vfe_dev->hw_info->vfe_ops.axi_ops.
+				get_ub_size(vfe_dev) /
 		axi_data->hw_info->num_wm;
-	} else {
-		pr_err("%s: incorrect VFE device\n ", __func__);
-	}
 	for (i = 0; i < axi_data->hw_info->num_wm; i++) {
 		msm_camera_io_w(ub_offset << 16 | (ub_equal_slice - 1),
-			vfe_dev->vfe_base + VFE47_WM_BASE(i) + 0x18);
+			vfe_dev->vfe_base +
+			vfe_dev->hw_info->vfe_ops.axi_ops.
+				ub_reg_offset(vfe_dev, i));
 		ub_offset += ub_equal_slice;
 	}
 }
 
-void msm_vfe47_cfg_axi_ub(struct vfe_device *vfe_dev)
+void msm_vfe47_cfg_axi_ub(struct vfe_device *vfe_dev,
+	enum msm_vfe_input_src frame_src)
 {
 	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
 
-	axi_data->wm_ub_cfg_policy = UB_CFG_POLICY;
+	axi_data->wm_ub_cfg_policy = MSM_WM_UB_CFG_DEFAULT;
 	if (axi_data->wm_ub_cfg_policy == MSM_WM_UB_EQUAL_SLICING)
 		msm_vfe47_cfg_axi_ub_equal_slicing(vfe_dev);
 	else
-		msm_vfe47_cfg_axi_ub_equal_default(vfe_dev);
+		msm_vfe47_cfg_axi_ub_equal_default(vfe_dev, frame_src);
 }
 
 void msm_vfe47_read_wm_ping_pong_addr(
@@ -2699,6 +2766,7 @@
 			.process_stats_irq = msm_isp_process_stats_irq,
 			.process_epoch_irq = msm_vfe47_process_epoch_irq,
 			.config_irq = msm_vfe47_config_irq,
+			.process_eof_irq = msm_isp47_process_eof_irq,
 		},
 		.axi_ops = {
 			.reload_wm = msm_vfe47_axi_reload_wm,
@@ -2726,6 +2794,8 @@
 			.restart = msm_vfe47_axi_restart,
 			.update_cgc_override =
 				msm_vfe47_axi_update_cgc_override,
+			.ub_reg_offset = msm_vfe47_ub_reg_offset,
+			.get_ub_size = msm_vfe47_get_ub_size,
 		},
 		.core_ops = {
 			.reg_update = msm_vfe47_reg_update,
